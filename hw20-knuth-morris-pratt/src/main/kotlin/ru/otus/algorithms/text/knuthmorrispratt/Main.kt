package ru.otus.algorithms.text.knuthmorrispratt

import java.util.*
import kotlin.collections.ArrayList
import kotlin.time.Duration.Companion.nanoseconds
import kotlin.time.DurationUnit

fun low(text: String, pattern: String): Int {
    if (text.isEmpty() || pattern.isEmpty()) return Int.MAX_VALUE
    return searchInStateMachine(text, pattern, prefixMatrix(pattern))
}

fun updateState(char: Char, pattern: String, matrix: Array<Int>, state: Int): Int {
    var newState = matrix[state]
    if (char == pattern[newState]) newState++
    if (newState == state) return state
    return updateState(char, pattern, matrix, newState)
}

fun prefixMatrix(string: String): Array<Int> {
    val pi = Array(string.length + 1) { 0 }
    for (idx in string.indices) {
        val line = string.substring(0, idx + 1)
        for (length in line.indices) {
            if (length < 2) pi[idx + 1] = 0
            val prefix = line.substring(0, length)
            val suffix = line.substring(line.length - length, line.length)
            if (prefix == suffix) {
                pi[idx + 1] = length
            }
        }
    }
    return pi
}

fun rapid(text: String, pattern: String): Int {
    if (text.isEmpty() || pattern.isEmpty()) return Int.MAX_VALUE
    return searchInStateMachine(text, pattern, knuthMorrisPratPrefixMatrix(pattern))
}

private fun searchInStateMachine(text: String, pattern: String, matrix: Array<Int>): Int {
    var state = 0
    for (idx in text.indices) {
        if (text[idx] == pattern[state]) state++
        else state = updateState(text[idx], pattern, matrix, state)
        if (state == matrix.indices.last) return idx - pattern.length + 1
    }
    return Int.MAX_VALUE
}

fun knuthMorrisPratPrefixMatrix(string: String): Array<Int> {
    val pi = Array(string.length + 1) { 0 }
    var length = 0
    for (idx in 1.. string.indices.last) {
        while (length > 0 && string[length] != string[idx]) length = pi[length]
        if (string[length] == string[idx]) length++
        pi[idx + 1] = length
    }
    return pi
}

fun main(args: Array<String>) {
    val text = """Проверка поискового поля от А до Я
4 МАЯ, 2022

В ходе создания любого программного обеспечения или сайта рано или поздно приходится осуществлять тестирование. Это – проверка работоспособности полученного софта. Осуществляется специально обученными людьми – тестировщиками. Иногда – потенциальной целевой аудиторией.

В данной статье будет рассказано о чек-листе для тестинга поисковой формы в пределах сайта. Также – раскрыто соответствующее понятие и его разновидности. В конце статьи – наглядный пример проверки.

Чек-лист – определение
Чек-лист представляет собой перечень, в котором находится ряд необходимых проверок для выполненной работы. Это – набор идей по тестингу, планированию, управлению и непосредственной разработки.

Важно учитывать, что тестовые случаи не должны зависеть друг от друга в соответствующем перечне. Состоит он из блоков, секций, страничек, а также иных элементов, которые необходимо проверить на работоспособность.

Содержание и цели
Чек лист обязательно содержит в себе следующие сведения:

идеи, выдвигаемые для непосредственной проверки формы или софта;
входная информация (набор);
ожидаемые результаты;
булевые отметки о прохождении или провале тестового случая;
булевые отметки, свидетельствующие о совпадении/несоответствии фактически полученных и ожидаемых результатов.
В чек лист можно включить шаги (этапы) проверки, информацию об особенностях задействованной среды. Это – только начало. В перечне должны содержаться материалы, имеющие значимость для тестинга.

Цель чек-листа – обеспечение стабильности покрытия требований проверками необходимыми и достаточными для заключения о соответствии продукции составленному ТЗ. Одна из особенностей – то, что соответствующий тип тестинга компонуется с тестовыми случаями, показательными для выдвинутого требования.

Разновидности
Чек-листы бывают нескольких типов: специальные и универсальные.

Первая категория предусматривает следующие особенности:

используются для конкретных проектов;
поля чек-листа будут соответствовать специфике всего проекта;
задача тестировщика – проверить возможность выполнения уникального действия, включенного в ТЗ.
Специальный чек лист не подойдет для проверки функционала «любого другого» приложения. Он составляется индивидуально для каждой разработки и функций.

Универсальный чек-лист:

подходит для приложений и сайтов схожего функционала;
не предусматривает привязку к географическим компонентам;
в этом случае нет определенной реализации;
позволяют провести проверку возможности пользователя выполнить определенную манипуляцию;
состоит из абстрактного списка проверок.
Пример – во время поиска должны выводиться указанные в поле запросы, а при проведении оплаты – подтверждение платежа. Если в интернет-магазине добавлять товары для покупки в профиль, они будут размещаться в «Корзине».

Принцип составления
Тестирование через чек-листы – это не самый трудный процесс, особенно если речь идет об универсальном тестинге. Но перед реализацией задачи нужно грамотно составить соответствующий «перечень задач».

Для этого рекомендуется соблюдать такие правила:

Один пункт – это единственный шаг. Минимальная полная операция, которая проводится тестером при проверке: одно соответствующее поле.
В качестве опоры необходимо выбрать требования. То, что не отражает ключевых функциональностей, можно пропустить.
Форма, которую имеет чеклист – универсальная для всех членов команды. Это необходимо, чтобы все разработчики имели единое представление о проверке и могли грамотно говорить, «на одном языке».
В зависимости от поставленной задачи необходимо детализировать соответствующий перечень.
Тот, кто подготавливает «список», может объединять их в матрицы. Оные предусматривают условия проверки, а также статус. Это – что-то среднее между чек-листом и тест-кейсом. Матрицы намного проще поддерживать.
Тестер запускает приложение или сайт, после чего, придерживаясь подготовленного перечня, осуществляет проверку поставленных задач.

Преимущества и недостатки
Перед применением рассмотренного элемента в разработке нужно оценить всего его плюсы и минусы. К сильным сторонам относят:

простота чтения;
быстрое подтверждение работоспособности кодификации;
служит в качестве источника результатов проверенной функциональности;
возможность проверки статуса в любое время.
К недостаткам запуска чек-листа можно отнести:

неопределенность тестовых наборов;
отсутствие четкой определенности тестовых сведений;
плохая детализация;
проблемы обучения, если нужно запустить тестинг среди начинающих;
меньшая эффективность для новичков.
Опытным разрабам такой вариант отлично подойдет. А тем, для кого тестирование только начинается, лучше прибегнуть к кейс-тестам.

Виды тестинга на сайте
Тест поля поиска – операция, которая выполняется в пределах того или иного сайта или приложения. Здесь можно выделить:

нагрузочное тестирование – производительности поискового модуля (или API при наличии);
тестинг безопасности;
изучение удобства использования поля поисковика;
тест функциональности;
релевантность поисковых результатов;
анализ парных поисковых запросов.
Также на обычном сайте можно протестить ввод логина и пароля для входа в профиль. Но эта операция встречается не везде.

Функциональный подход
Проверка функционала поиска включает в себя:

чувствительность к регистру – обычно отсутствует;
результат выдается при клике по «Поиск» или Enter на клавиатуре;
анализ принципов выдачи результатов посредством фильтров;
тестинг по вхождению текста;
выделение в множестве запросов поиска классов эквивалентности;
тест корректности выполнения задач;
переход «от частного в общему».
Если на сайте есть авторизация – можно и нужно удостовериться в правильности поиска логина для запуска ЛК.

Несколько слов о релевантности
Для успешного запуска сайта с поисковой строчкой важен грамотный тестинг. Не только логина, но и других данных. Для этого нужно использовать чек-лист.

Второй этап – это оценка релевантности запросов. Выступает важным параметром для функционирования поисковой системы. Показывает, насколько обнаруженные объекты соответствуют первоначальному запросу.

Оценка производится несколькими способами:

Через загрузки асессоров (оценщиков). Это – люди, которые вручную проверяют соответствие документа сформированному запросу.
На основе онлайн-метрик сайта. А именно – по количеству кликов на результаты поиска, добавлений в корзину (для магазинов).
Если запрос найден успешно и точно – все работает нормально.

Парные запросы
Последний этап – это анализ парных запросов:

синонимов;
корректных запросов и с опечатками;
с пропуском пробела;
с разным порядком слов;
запрос с ошибкой раскладки клавиатуры;
морфология;
версия транслитерации;
запросы со вспомогательными словами.
Во всем этом быстро сориентироваться поможет хорошо составленный чек-лист.

Как лучше понимать тему
Для того, чтобы лучше разобраться в описанном процессе, можно:

Посмотреть разнообразные туториалы. Пример – этот сайт. Здесь опубликованы видео-уроки на русском языке, которые помогут стать тестировщиком с нуля.
Изучить документацию по чек-листам самостоятельно. В Сети полно подходящих материалов.
Обучиться на тестировщика в ВУЗе или техникуме. Второй вариант не слишком распространен в России.
Еще один вариант – это прохождение онлайн-курсов. Специализированные программы подойдут и новичкам, и опытным программерам. На них доступным языком расскажут о чек-листе тестирования, а также иных особенностях процесса.

P. S. Большой выбор курсов по тестированию есть и в Otus. Среди них широко представлено и направление автоматизации. Есть варианты как для продвинутых, так и для начинающих пользователей.

"""
    val pattern = "провер"
    val base = 10
    val list = ArrayList<Array<Long>>()
    println("low(${text.length}, $pattern) ${low(text, pattern)}")
    println("rapid(${text.length}, $pattern) ${rapid(text, pattern)}")
    val exponent = 6
    for (i in 3..exponent) list.add(executor((Math.pow(base.toDouble(), i.toDouble())).toInt(), text, pattern))
    println("low(${"недопроведопроверка".length}, $pattern) ${low("недопроведопроверка", pattern)}")
    println("rapid(${"недопроведопроверка".length}, $pattern) ${rapid("недопроведопроверка", pattern)}")
    for (i in 3..exponent) list.add(executor((Math.pow(base.toDouble(), i.toDouble())).toInt(), "недопроведопроверка", pattern))
    for (idx in list.indices) {
        println(" ${list.get(idx)[0]} ${if (idx < list.size / 2) "длинный текст" else "корроткий текст"}  ${list.get(idx)[1]}  ${list.get(idx)[2]}  ${(list.get(idx)[1].toDouble() / list.get(idx)[2])}")
    }
}

private fun executor(count: Int, text: String, pattern: String): Array<Long> {
    val array = Array(3) {count.toLong()}
    var start = Date().time.nanoseconds.toLong(DurationUnit.NANOSECONDS)
    for (i in 0..count) low(text, pattern)
    array[1] = Date().time.nanoseconds.toLong(DurationUnit.NANOSECONDS) - start
    start = Date().time.nanoseconds.toLong(DurationUnit.NANOSECONDS)
    for (i in 0..count) rapid(text, pattern)
    array[2] = Date().time.nanoseconds.toLong(DurationUnit.NANOSECONDS) - start
    return array
}
